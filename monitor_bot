import os
import logging
import asyncio
import sqlite3
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telethon import TelegramClient, events
from telethon.sessions import StringSession
import re

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class MonitorBot:
    def __init__(self, token: str):
        self.token = token
        self.app = Application.builder().token(token).build()
        self.active_clients = {}
        self.setup_handlers()
        self.init_db()

    def init_db(self):
        conn = sqlite3.connect('monitor_filters.db')
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS filters (
                user_id INTEGER,
                session_string TEXT,
                filter_type TEXT,
                filter_value TEXT,
                PRIMARY KEY (user_id, session_string, filter_type)
            )
        ''')
        conn.commit()
        conn.close()

    def setup_handlers(self):
        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CommandHandler("addmonitor", self.add_monitor))
        self.app.add_handler(CommandHandler("stopmonitor", self.stop_monitor))
        self.app.add_handler(CommandHandler("mymonitors", self.my_monitors))
        self.app.add_handler(CommandHandler("addfilter", self.add_filter))
        self.app.add_handler(CommandHandler("myfilters", self.my_filters))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        welcome_text = """
üëÅÔ∏è **–ë–æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ Telegram**

üìã –ö–æ–º–∞–Ω–¥—ã:
/addmonitor - –î–æ–±–∞–≤–∏—Ç—å —Å–µ—Å—Å–∏—é –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
/stopmonitor - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
/mymonitors - –ê–∫—Ç–∏–≤–Ω—ã–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∏
/addfilter - –î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä
/myfilters - –ú–æ–∏ —Ñ–∏–ª—å—Ç—Ä—ã

–î–ª—è –Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /addmonitor —Å session string
        """
        await update.message.reply_text(welcome_text, parse_mode='Markdown')

    async def add_monitor(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "üîê **–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞**\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ session string:\n"
            "(–ø–æ–ª—É—á–µ–Ω–Ω—ã–π –æ—Ç @YourSessionBot)"
        )
        context.user_data['awaiting_session'] = True

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if context.user_data.get('awaiting_session'):
            await self.process_new_session(update, context, update.message.text)
        elif context.user_data.get('awaiting_filter'):
            await self.process_new_filter(update, context, update.message.text)

    async def process_new_session(self, update: Update, context: ContextTypes.DEFAULT_TYPE, session_string: str):
        user_id = update.effective_user.id
        
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è —Å —ç—Ç–æ–π —Å–µ—Å—Å–∏–µ–π
            client = TelegramClient(StringSession(session_string), 1, "b")
            await client.start()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
            me = await client.get_me()
            if not me:
                await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Å–µ—Å—Å–∏—è –∏–ª–∏ —Å–µ—Å—Å–∏—è —É—Å—Ç–∞—Ä–µ–ª–∞")
                await client.disconnect()
                return
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–ª–∏–µ–Ω—Ç
            key = f"{user_id}_{session_string[:20]}"
            self.active_clients[key] = client
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π
            @client.on(events.NewMessage)
            async def handler(event):
                if event.is_private:  # –¢–æ–ª—å–∫–æ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                    await self.process_monitored_message(user_id, event.message, session_string)
            
            await update.message.reply_text(
                f"‚úÖ **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω!**\n\n"
                f"üì± –ê–∫–∫–∞—É–Ω—Ç: {me.phone}\n"
                f"üë§ –ò–º—è: {me.first_name or 'N/A'}\n\n"
                f"–¢–µ–ø–µ—Ä—å –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã –∫–æ–º–∞–Ω–¥–æ–π /addfilter"
            )
            
            context.user_data.pop('awaiting_session', None)
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

    async def process_monitored_message(self, user_id: int, message, session_string: str):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ–∏–ª—å—Ç—Ä—ã"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏
            conn = sqlite3.connect('monitor_filters.db')
            cursor = conn.cursor()
            filters = cursor.execute(
                'SELECT filter_type, filter_value FROM filters WHERE user_id = ? AND session_string = ?',
                (user_id, session_string)
            ).fetchall()
            conn.close()
            
            message_text = message.text or ""
            sender = await message.get_sender()
            sender_name = getattr(sender, 'first_name', 'Unknown') or 'Unknown'
            sender_phone = getattr(sender, 'phone', 'Unknown')
            
            # –ï—Å–ª–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –Ω–µ—Ç - –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –≤—Å–µ
            if not filters:
                await self.forward_message(user_id, message, sender_name, sender_phone, "–ë–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞")
                return
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
            for filter_type, filter_value in filters:
                if filter_type == "keyword" and filter_value.lower() in message_text.lower():
                    await self.forward_message(user_id, message, sender_name, sender_phone, f"–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ: {filter_value}")
                    break
                elif filter_type == "regex" and re.search(filter_value, message_text, re.IGNORECASE):
                    await self.forward_message(user_id, message, sender_name, sender_phone, f"Regex: {filter_value}")
                    break
                elif filter_type == "all":  # –§–∏–ª—å—Ç—Ä "–≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è"
                    await self.forward_message(user_id, message, sender_name, sender_phone, "–í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è")
                    break
                    
        except Exception as e:
            logger.error(f"Error processing monitored message: {e}")

    async def forward_message(self, user_id: int, message, sender_name: str, sender_phone: str, filter_info: str):
        """–ü–µ—Ä–µ—Å—ã–ª–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        try:
            text = f"üì® **–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ**\n\n"
            text += f"üë§ –û—Ç: {sender_name}\n"
            text += f"üì± –ù–æ–º–µ—Ä: {sender_phone}\n"
            text += f"üîç –§–∏–ª—å—Ç—Ä: {filter_info}\n"
            text += f"üí¨ –¢–µ–∫—Å—Ç: {message.text}\n"
            text += f"‚è∞ –í—Ä–µ–º—è: {message.date.strftime('%Y-%m-%d %H:%M:%S')}"
            
            await self.app.bot.send_message(user_id, text, parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error forwarding message: {e}")

    async def add_filter(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        
        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_sessions = [k for k in self.active_clients.keys() if k.startswith(str(user_id))]
        
        if not user_sessions:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–≤. –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ —Å–µ—Å—Å–∏—é.")
            return
        
        response = "üîç **–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞**\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞:\n\n"
        response += "1. **keyword** - –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É\n"
        response += "2. **regex** - –ø–æ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–º—É –≤—ã—Ä–∞–∂–µ–Ω–∏—é\n"
        response += "3. **all** - –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è\n\n"
        response += "–û—Ç–≤–µ—Ç—å—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: `—Ç–∏—Ñ_—Ñ–∏–ª—å—Ç—Ä–∞ –∫–ª—é—á–µ–≤–æ–µ_—Å–ª–æ–≤–æ`\n"
        response += "–ü—Ä–∏–º–µ—Ä: `keyword –ø—Ä–∏–≤–µ—Ç`"
        
        await update.message.reply_text(response, parse_mode='Markdown')
        context.user_data['awaiting_filter'] = True

    async def process_new_filter(self, update: Update, context: ContextTypes.DEFAULT_TYPE, filter_text: str):
        user_id = update.effective_user.id
        
        try:
            parts = filter_text.split(' ', 1)
            if len(parts) < 2:
                await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: `—Ç–∏–ø_—Ñ–∏–ª—å—Ç—Ä–∞ –∑–Ω–∞—á–µ–Ω–∏–µ`")
                return
            
            filter_type, filter_value = parts[0].lower(), parts[1]
            
            if filter_type not in ['keyword', 'regex', 'all']:
                await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø —Ñ–∏–ª—å—Ç—Ä–∞. –î–æ—Å—Ç—É–ø–Ω–æ: keyword, regex, all")
                return
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_sessions = [k for k in self.active_clients.keys() if k.startswith(str(user_id))]
            
            conn = sqlite3.connect('monitor_filters.db')
            cursor = conn.cursor()
            
            for session_key in user_sessions:
                session_string = session_key.split('_', 1)[1] + "..."  # –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
                cursor.execute(
                    'INSERT OR REPLACE INTO filters (user_id, session_string, filter_type, filter_value) VALUES (?, ?, ?, ?)',
                    (user_id, session_string, filter_type, filter_value)
                )
            
            conn.commit()
            conn.close()
            
            await update.message.reply_text(f"‚úÖ –§–∏–ª—å—Ç—Ä –¥–æ–±–∞–≤–ª–µ–Ω: {filter_type} - {filter_value}")
            context.user_data.pop('awaiting_filter', None)
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

    async def my_monitors(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user_sessions = [k for k in self.active_clients.keys() if k.startswith(str(user_id))]
        
        if not user_sessions:
            await update.message.reply_text("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–≤")
            return
        
        response = "üëÅÔ∏è **–ê–∫—Ç–∏–≤–Ω—ã–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∏:**\n\n"
        for i, session_key in enumerate(user_sessions, 1):
            client = self.active_clients[session_key]
            me = await client.get_me()
            response += f"{i}. {me.phone} - {me.first_name or 'N/A'}\n"
        
        await update.message.reply_text(response)

    async def stop_monitor(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        user_sessions = [k for k in self.active_clients.keys() if k.startswith(str(user_id))]
        
        if not user_sessions:
            await update.message.reply_text("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–≤ –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
            return
        
        stopped_count = 0
        for session_key in user_sessions:
            client = self.active_clients[session_key]
            await client.disconnect()
            del self.active_clients[session_key]
            stopped_count += 1
        
        await update.message.reply_text(f"‚úÖ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {stopped_count} –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–≤")

    def run(self):
        self.app.run_polling()

if __name__ == "__main__":
    # –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—Ç @BotFather
    BOT_TOKEN = "8527648932:AAGvTV7JZz6IsajjTmAQH3zzyvXJNvvVO1o"
    
    monitor_bot = MonitorBot(BOT_TOKEN)
    print("–ë–æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–ø—É—â–µ–Ω...")
    monitor_bot.run()
